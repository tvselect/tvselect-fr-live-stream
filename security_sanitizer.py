import logging
import re
import socket

class SensitiveDataFilter(logging.Filter):
    """
    A log-scrubbing filter designed for high-security environments.

    Features:
      - Redacts sensitive keywords (generic scrub)
      - Redacts exact secret values after update_patterns() is called
      - Scrubs:
            * record.msg
            * record.args
            * record.exc_info (exception messages)
            * record.exc_text (formatted traceback text)
            * tracebacks printed by logger.exception()
      - Prevents leakage of secrets in logs AND Sentry

    This filter MUST be installed BEFORE any secrets are loaded and BEFORE
    any logging occurs, to avoid pre-scrubber leak windows.
    """

    GENERIC_SENSITIVE_WORDS = [
        "password", "token", "secret", "credential", "auth", "authorization"
    ]

    def __init__(self, secrets=None):
        super().__init__()
        self.secret_patterns = []

        if secrets:
            self.update_patterns(secrets)

    def update_patterns(self, secrets: dict):
        """
        Add exact secret values to redact.
        Call this AFTER secrets are loaded.
        """
        self.secret_patterns = []

        for _, value in secrets.items():
            if not value:
                continue

            # Escape exact secret value for safe regex
            pattern = re.escape(str(value))
            self.secret_patterns.append(re.compile(pattern))

    def _scrub_string(self, text: str) -> str:
        """Apply generic and exact-pattern scrubbing to any string."""

        if not text:
            return text

        lowered = text.lower()

        # 1. Generic keyword scrubbing (Catching 'key: value' patterns)
        for word in self.GENERIC_SENSITIVE_WORDS:
            if word in lowered:
                # Only redact if the word is followed by an assignment operator (= or :)
                # This matches: "password: my_secret", "token=12345", "auth :  xyz"
                # It will NOT match: "The credentials are missing"
                text = re.sub(
                    r"(?i)(" + re.escape(word) + r")\s*[:=]\s*[^\s,]+",
                    r"\1=[REDACTED]",
                    text,
                )

        # 2. Precise secret scrubbing (after update_patterns())
        for pattern in self.secret_patterns:
            text = pattern.sub("[REDACTED]", text)

        return text

    def filter(self, record):
        """Main entry point for Python's logging framework."""

        # Scrub main message
        if record.msg:
            record.msg = self._scrub_string(str(record.msg))

        # Scrub arguments
        if record.args:
            new_args = []
            for arg in (record.args if isinstance(record.args, tuple) else [record.args]):
                if isinstance(arg, str):
                    new_args.append(self._scrub_string(arg))
                else:
                    new_args.append(arg)

            record.args = tuple(new_args)

        # Scrub exception info (type, value, traceback)
        if record.exc_info:
            etype, evalue, tb = record.exc_info

            if evalue and hasattr(evalue, "args"):
                new_args = []
                for a in evalue.args:
                    if isinstance(a, str):
                        new_args.append(self._scrub_string(a))
                    else:
                        new_args.append(a)
                evalue.args = tuple(new_args)

        # Scrub formatted traceback text (generated by handler formatters)
        if hasattr(record, "exc_text") and record.exc_text:
            record.exc_text = self._scrub_string(record.exc_text)

        return True

global_sanitizer = SensitiveDataFilter()

def scrub_event(event, hint):
    """
    Privacy-hardened Sentry scrubber.
    Removes credentials, usernames in paths, hostnames, absolute paths,
    cwd, argv, and sensitive context values.
    """

    # Use the global instance so it "sees" the same secrets as the logger
    scrub = global_sanitizer._scrub_string

    # Resolve actual hostname once (fast)
    try:
        REAL_HOSTNAME = socket.gethostname()
    except Exception:
        REAL_HOSTNAME = None

    # Regex to scrub usernames in paths
    USER_HOME_RE = re.compile(r"/home/[^/]+")
    def redact_user_home(value: str) -> str:
        return USER_HOME_RE.sub("/home/REDACTED_USER", value)

    # Safely redact hostname (only when exact match or substring match)
    def redact_hostname(value: str) -> str:
        if REAL_HOSTNAME and REAL_HOSTNAME in value:
            return value.replace(REAL_HOSTNAME, "[REDACTED_HOST]")
        return value

    def sanitize_value(value):
        if isinstance(value, str):
            value = scrub(value)
            value = redact_user_home(value)
            value = redact_hostname(value)
        return value

    def sanitize_dict(d):
        for key, val in list(d.items()):
            if isinstance(val, str):
                d[key] = sanitize_value(val)
            elif isinstance(val, dict):
                sanitize_dict(val)
            elif isinstance(val, list):
                d[key] = [sanitize_value(item) for item in val]
        return d

    # -------- Scrub event structure --------

    if "server_name" in event:
        event["server_name"] = "[REDACTED_HOST]"

    if "request" in event:
        sanitize_dict(event["request"])

    if "extra" in event:
        sanitize_dict(event["extra"])

    if "exception" in event:
        for exc in event["exception"].get("values", []):
            if "value" in exc:
                exc["value"] = sanitize_value(exc["value"])

            if "stacktrace" in exc:
                frames = exc["stacktrace"].get("frames", [])
                for frame in frames:
                    for k in ("filename", "abs_path", "context_line", "function"):
                        if k in frame:
                            frame[k] = sanitize_value(frame[k])

                    if "vars" in frame:
                        sanitize_dict(frame["vars"])

    if "contexts" in event:
        sanitize_dict(event["contexts"])

    if "breadcrumbs" in event:
        for crumb in event["breadcrumbs"].get("values", []):
            sanitize_dict(crumb)

    # Redact sys.argv and cwd explicitly
    if "extra" in event:
        if "sys.argv" in event["extra"]:
            event["extra"]["sys.argv"] = ["[REDACTED_ARG]"]

        if "cwd" in event["extra"]:
            event["extra"]["cwd"] = "[REDACTED_CWD]"

    return event
